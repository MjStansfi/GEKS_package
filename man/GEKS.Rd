% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/user_GEKS.R
\name{GEKS}
\alias{GEKS}
\title{GEKS-tornqvist}
\usage{
GEKS(
  times,
  price,
  id,
  features = NULL,
  window_length,
  weight = NULL,
  splice_pos = "mean",
  index_method = "tornqvist",
  num_cores = NULL
)
}
\arguments{
\item{times}{vector of the times at which price observations were made. \cr
NOTE: \code{times} must be of class Date or numeric.}

\item{price}{vector of log of prices at the given time}

\item{id}{vector of distinct identification number of consumer goods}

\item{features}{required if calculating 'impute-tornqvist'. Data.frame of features.}

\item{window_length}{single number for length of windows of the data that
regressions are fit on}

\item{weight}{vector of expenditure weights used in the regressions}

\item{splice_pos}{The position on which to splice the windows together.
This can be a number from 1 to window_length or any of
c("window", "half","movement", "mean").}

\item{index_method}{A character string to select the index number method.
Valid index number methods are fisher, tornqvist, impute-tronqvist. The default is tornqvist. (see ?IndexNumR::GEKSIndex)}

\item{num_cores}{Number of cores to use for parallel computation.
Convention is parallel::detectCores()-1 on local machines}
}
\value{
The function returns a list of 3 items:
    \describe{
        \item{\strong{geks}}{a dataframe of the GEKS index}
        \item{\strong{fixed_effects}}{a dataframe of the unspliced coefficients
        of the fixed effects model. The number of rows in the data frame is
        \code{window_length} * the number of windows in the data}
         \item{\strong{diagnostics}}{a dataframe of diagnostic results
         produced during model calculation. The diagnostics dataframe has the
         following columns:}
         \describe{
              \item{\strong{contrib_rids_pc}}{the \% of ids which exist in
              the window and contribute to the index i.e. the id has at least
              2 prices in the window}
              \item{\strong{contrib_rids_nm}}{the number of ids which exist
              in the window that contribute}
              \item{\strong{total_rids_in_data}}{number of ids in the entire
               dataset}
              \item{\strong{total_rids_in_window}}{number of ids which have
              any prices in the window}
              \item{\strong{num_records_in_window}}{The number of rows of
              data in this window}
              \item{\strong{QU_1st}}{25\% of the id's have less than this many
              prices in the window}
              \item{\strong{gm_mean_entries_per_rid}}{the geometric mean
              number of prices per id in this window}
              \item{\strong{mean_entries_per_rid}}{the mean number of prices
               per rid in this window}
              \item{\strong{median_entries_per_rid}}{the median number of
              prices per rid in this window}
              \item{\strong{QU_3rd}}{75\% of the id's have less than this many
              prices in the window}
              \item{\strong{window_id}}{identifier for the window}
              }
              }
}
\description{
Takes a time series of prices and id's and returns an index using the GEKS
method.
}
\details{
The function takes vectors for each of the inputs. It is important to note
that the \code{times} argument must be of numeric or Date class. This is because
the order of the dates matters. \cr \cr
The function also has the capability to run in parallel, using the
\code{num_cores} argument. Note that for smaller datasets using non-parallel
code is often faster than using parallelisation due to the overhead
associated with dividing the job across multiple processors.
}
\examples{
GEKS(times = turvey$month,
price = turvey$price,
id = turvey$commodity,
window_length = 5,
weight = turvey$price * turvey$quantity,
splice_pos = "mean",
num_cores = NULL)

GEKS(times = turvey$month,
price = turvey$price,
id = turvey$commodity,
window_length = 5,
weight = turvey$price * turvey$quantity,
splice_pos = "mean",
num_cores = 2)

}
